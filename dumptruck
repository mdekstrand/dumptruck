#!/usr/bin/env zsh

zmodload zsh/zutil
zmodload zsh/pcre
zmodload zsh/stat
zmodload zsh/datetime

setopt PIPE_FAIL
setopt NULL_GLOB
setopt REMATCH_PCRE

######
# Initialize environment variables to their defaults
: "${AGE:=age}"
: "${BACKUP_METHOD:=gnutar}"
: "${BACKUP_NAME:=backup}"
# BACKUP_LEVEL (auto-detected)
# BACKUP_DIR (required)
: "${BACKUP_SCHEDULE:=monthly}"
: "${BACKUP_WORK:=/var/lib/dumptruck}"
# RECIPIENT_FILE (auto)
# TAR (auto-detected)
opt_cleanup=0
opt_dry=0
opt_verbose=0
opt_onefs=0
action=default

# working variables
typeset -a BACKUPS
# BACKUP_FILE
# BACKUP_TMP
typeset -a BACKUP_OUT
typeset -a TEMP_FILES

# environment times
OS="$(uname)"
if [[ $_DT_BACKUP_TIME ]]; then
	BACKUP_TIME="$_DT_BACKUP_TIME"
else
	BACKUP_TIME="$epochtime[1]"
fi

#region Logging functions
msg() {
	local pfx="%BMSG:%b"
	local sfx=""
	case "$1" in
	-dbg | -debug)
		pfx="%F{cyan}DBG:"
		sfx="%f"
		if ((!$opt_verbose)); then
			return
		fi
		shift
		;;
	-info)
		shift
		;;
	-warn)
		pfx="%B%F{yellow}WRN:"
		sfx="%f%b"
		shift
		;;
	-err | -error)
		pfx="%B%F{red}ERR:"
		sfx="%f%b"
		shift
		;;
	esac
	print -P "$pfx $*$sfx" >&2
}
#endregion

#region Log level support management

# Auto-detect level as needed
configure_level() {
	local match cl
	if [[ -z "$BACKUP_LEVEL" ]]; then
		schedule_${BACKUP_SCHEDULE}_level
		if (($?)); then
			msg -error "$BACKUP_SCHEDULE level failed"
			exit 100
		fi
	else
		msg "Level $BACKUP_LEVEL backup explicitly requested"
	fi

	if ((${#BACKUPS} == 0)); then
		msg "no backups exist, using L0"
		BACKUP_LEVEL=0
	elif (($BACKUP_LEVEL > 0)); then
		pcre_compile "^$BACKUP_NAME-[\d:-]+\.L(\d)\.$FTYPE\.zst(?:\.age)?$" || exit 100
		if pcre_match "$BACKUPS[-1]"; then
			msg -debug "last backup level: $match[1]"
			if (($BACKUP_LEVEL > "$match[1]" + 1)); then
				cl="$BACKUP_LEVEL"
				BACKUP_LEVEL=$(("$match[1]" + 1))
				msg "last level is $match[1], adjusting level $cl -> $BACKUP_LEVEL"
			fi
		else
			msg -warn "invalid backup name $BACKUPS[-1]"
		fi
	fi
}
#endregion

#region Log schedules

schedule_monthly_level() {
	local ltime=$(_last_backup_time)
	typeset -A last=($(_parse_time "$ltime"))

	msg "selecting backup level by monthly schedule (last backup: $last[iso])"

	if [[ $NOW[date] = $last[date] ]]; then
		msg "second backup of the day, requesting L3"
		BACKUP_LEVEL=3
	elif [[ "$last[year]-$last[month]" != "$NOW[year]-$NOW[month]" ]]; then
		msg "new month, requesting L0 backup"
		BACKUP_LEVEL=0
	elif [[ "$last[year]-$last[week]" != "$NOW[year]-$NOW[week]" ]]; then
		msg "new week, requesting L1 backup"
		BACKUP_LEVEL=1
	else
		msg "new day, requesting L2 backup"
		BACKUP_LEVEL=2
	fi
}

schedule_monthly_prune() {
	_prune_backups_for_level 3 12
	_prune_backups_for_level 2 10
	_prune_backups_for_level 1 5
	_prune_backups_for_level 0 12
}

schedule_yearly_level() {
	local ltime=$(_last_backup_time)
	typeset -A last=($(_parse_time "$ltime"))

	msg "selecting backup level by yearly schedule (last backup: $last[iso])"

	if [[ $NOW[date] = $last[date] ]]; then
		msg "second backup of the day, requesting L4"
		BACKUP_LEVEL=4
	elif [[ "$last[year]-$last[month]" != "$NOW[year]-$NOW[month]" ]]; then
		msg "new month, requesting L1 backup"
		BACKUP_LEVEL=1
	elif [[ "$last[year]-$last[week]" != "$NOW[year]-$NOW[week]" ]]; then
		msg "new week, requesting L2 backup"
		BACKUP_LEVEL=2
	else
		msg "new day, requesting L3 backup"
		BACKUP_LEVEL=3
	fi
}

schedule_yearly_prune() {
	_prune_backups_for_level 4 12
	_prune_backups_for_level 3 10
	_prune_backups_for_level 2 5
	_prune_backups_for_level 1 14
	_prune_backups_for_level 0 5
}

_parse_time() {
	local time="$1" match sep
	if [[ -z "$time" ]]; then
		time="$epochtime[1]"
	fi
	msg -debug "parsing time $time"
	if [[ $time =~ '^\d+-\d+-\d+([T -])\d+:\d+:\d+$' ]]; then
		sep="$match[1]"
		strftime -r -s time "%Y-%m-%d${sep}%H:%M:%S" "$time"
	elif [[ $time =~ '^\d+-\d+-\d+([T -])\d+:\d+$' ]]; then
		sep="$match[1]"
		strftime -r -s time "%Y-%m-%d${sep}%H:%M" "$time"
	elif [[ $time =~ '^\d+-\d+-\d+$' ]]; then
		strftime -r -s time '%Y-%m-%d' "$time"
	elif [[ $time =~ "^\d+$" ]]; then
		# everything is fine
	else
		msg -error "invalid time $time"
		exit 2
	fi

	msg -debug "extracting from time $time"
	echo unix $time
	strftime "date %F" "$time"
	strftime "iso %FT%H:%M:%S" "$time"
	strftime "year %Y" "$time"
	strftime "month %m" "$time"
	strftime "day %f" "$time"
	strftime "week %V" "$time"
}

_last_backup_time() {
	scan_backups
	pcre_compile '^.*?-(\d+-\d+-\d+)(-\d+:\d+:\d+)?'
	if ((${#BACKUPS})) && pcre_match "$BACKUPS[-1]"; then
		if [[ $match[2] ]]; then
			msg -debug "backup $BACKUPS[-1] contains full time"
			last="$match[1]$match[2]"
			strftime -r -s ltime "%Y-%m-%d-%H:%M:%S" "$last"
		else
			msg -debug "backup $BACKUPS[-1] contains only date"
			last="$match[1]"
			strftime -r -s ltime "%Y-%m-%d" "$last"
		fi
		msg -debug "last backup on $last ($ltime)"
		echo $ltime
	fi
}

#endregion

#region Backup file management

# scan existing backups files into the BACKUPS array
scan_backups() {
	local name file level backups match search_name search_type
	level=
	if [[ $1 = -a ]]; then
		msg -debug "searching for all $FTYPE backups"
		search_name=".+?"
		search_type="\w+"
		shift
	else
		msg -debug "scanning for $FTYPE backups named $BACKUP_NAME"
		search_name="$BACKUP_NAME"
		search_type="$FTYPE"
	fi
	backups=()
	if [[ $1 =~ -[[:digit:]] ]]; then
		level="${1#-}"
		msg -debug "limiting to level $level"
	fi
	pcre_compile "^$search_name-[\d:-]+\.L(\d)\.$search_type\.zst(?:\.age)?$" || exit 100
	for file in "$BACKUP_DIR"/*; do
		name="$(basename $file)"
		if pcre_match "$name"; then
			if [[ -z $level || $match[1] = $level ]]; then
				msg -debug "found backup $name"
				backups+="$name"
			fi
		else
			msg -debug "file $name does not match backup pattern"
		fi
	done

	# sort the array
	msg -debug "scanned ${#backups} backups"
	set -sA BACKUPS "$backups[@]"
}

# list the backup files
list_backups() {
	local name level date enc method i pad etag size
	name=
	scan_backups -a
	msg -debug "listing ${#BACKUPS} backups"
	pcre_compile "^(.*?)-([\d:-]+)\.L(\d)\.(\w+)\.zst(\.age)?$" || exit 100
	for backup in "$BACKUPS[@]"; do
		if ! pcre_match "$backup"; then
			msg -error "invalid backup file: $backup"
			continue
		fi
		if [[ $match[1] != $name ]]; then
			name="$match[1]"
			print -P "%BBackups for %F{magenta}$name%f:%b"
		fi
		date="$match[2]"
		level="$match[3]"
		method="$match[4]"
		enc="$match[5]"
		pad="  "
		size=$(_friendly_size "$BACKUP_DIR/$backup")
		for ((i = 0; i < $level; i++)); do
			pad="$pad  "
		done
		etag=
		if [[$enc]]; then
			etag=", %B%F{green}encrypted%f%b"
		fi
		print -P "$pad%BL$level:%b %F{yellow}$size%f %F{cyan}$date%f (%F{blue}$method%f$etag)"
	done
}

_friendly_size() {
	local size sizes prefix stat
	zstat -H stat "$1"
	if (($?)); then
		return "$?"
	fi
	size="$stat[size]"
	msg -debug "formatting $1 size $size"
	sizes=(K M G T E)
	prefix=
	while (($size > 1024)); do
		prefix="$sizes[1]iB"
		shift sizes
		size=$(($size / 1024.0))
	done
	printf "%.1f%s" "$size" "$prefix"
}

# clean up the backups according to expiration
clean_backups() {
	schedule_${BACKUP_SCHEDULE}_prune
}

_prune_backups_for_level() {
	local level="$1" count="$2" n file
	scan_backups "-$level"
	msg "found ${#BACKUPS} L$level backups, want to keep $count"
	while ((${#BACKUPS} > $count)); do
		file="$BACKUPS[1]"
		shift BACKUPS
		if (($opt_dry)); then
			msg "would remove $file"
		else
			rm "$BACKUP_DIR/$file"
		fi
	done
}

#endregion

#region GNUTAR backup method

_fs_type() {
	if [[ $OS = Linux ]]; then
		# use stat binary, zstat doesn't give FS type
		command stat -f -c %T "$1"
	else
		echo "unknown"
	fi
}

gnutar_init() {
	local tar_version
	if [[ -z $TAR ]]; then
		msg -debug "looking for tar implementation"
		if [[ -v commands[gtar] ]]; then
			TAR=gtar
		else
			TAR=tar
		fi
	fi
	msg -debug "checking if $TAR is GNU"
	tar_version="$($TAR --version | head -1)"
	msg -debug "$TAR is $tar_version"
	if [[ $tar_version =~ "GNU tar" ]]; then
		msg -debug "$TAR is ok"
	else
		msg -error "$TAR does not appear to be GNU tar"
		exit 3
	fi

	msg -debug "gnutar ready to go"
}

gnutar_prepare() {
	local prev_snar prev_level ec snstat
	GT_SNAR="$BACKUP_NAME.L$BACKUP_LEVEL.snar"
	msg -debug "preparing for level $BACKUP_LEVEL gnutar backup"
	if (($BACKUP_LEVEL > 0)); then
		prev_level=$((BACKUP_LEVEL - 1))
		msg -debug "looking for $prev_level incremental list"
		prev_snar="$BACKUP_NAME.L$prev_level.snar"
		zstat -H snstat -F "%+" "$BACKUP_WORK/$prev_snar"
		if (($? == 0)); then
			msg "L$prev_level backup modified at $snstat[mtime]"
			if ((!$opt_dry)); then
				TEMP_FILES+="$BACKUP_WORK/$GT_SNAR.tmp"
				cp "$BACKUP_WORK/$prev_snar" "$BACKUP_WORK/$GT_SNAR.tmp"
			fi
		else
			msg -warn "$prev_snar does not exist, re-requesting L$prev_level backup"
			BACKUP_LEVEL=$prev_level
			gnutar_prepare
			ec="$?"
			setup_output
			return "$ec"
		fi
	fi

	if ((!$opt_dry)); then
		mkdir -p "$BACKUP_WORK"
		cat >"$BACKUP_WORK/CACHEDIR.TAG" <<EOF
Signature: 8a477f597d28d172789f06886806bc55
# This is the working directory for dumptruck --listed-incremental files.
# Its contents don't need to be backed up.
EOF
	fi
}

gnutar_backup() {
	local tar_cmd fs fixed_fs=0
	msg "creating gnutar backup at $BACKUP_FILE"
	tar_cmd=(tar cf - --listed-incremental="$BACKUP_WORK/$GT_SNAR.tmp" --exclude-caches)
	if (($opt_onefs)); then
		tar_cmd+='--one-file-system'
	fi
	for tgt in "$@"; do
		fs="$(_fs_type "$1")"
		msg -debug "checking fs $fs"
		case "$fs" in
		zfs)
			if ((!$fixed_fs)); then
				msg "file system $fs does not support device checks, disabling"
				if ((!$opt_onefs)); then
					msg -warn "disabling device checks on multiple filesystems may corrupt backups"
				fi
				tar_cmd+='--no-check-device'
				fixed_fs=1
			fi
			;;
		esac
	done
	tar_cmd+=("$@")
	msg -debug "backup command: $tar_cmd"
	if ((!$opt_dry)); then
		if ! "$tar_cmd[@]" | write_backup; then
			msg -error "failed to write backup"
			exit 4
		fi
	fi
}

gnutar_save() {
	if ((!$opt_dry)); then
		msg -debug "moving temporary $BACKUP_WORK/$GT_SNAR.tmp"
		mv "$BACKUP_WORK/$GT_SNAR.tmp" "$BACKUP_WORK/$GT_SNAR" || exit 2
	fi
}

#endregion

#region XFSDUMP backup method

xfsdump_init() {
	if [[ ! -v commands[xfsdump] ]]; then
		msg -error "xfsdump not found"
		exit 3
	fi

	msg -debug "xfsdump ready to go"
}

xfsdump_prepare() {
	# xfsdump requies no preparation
}

xfsdump_backup() {
	if (($# > 1)); then
		msg -error "XFS can only back up single paths"
		exit 3
	fi
	if ((!$opt_dry)); then
		if ! xfsdump -L "dumptruck-$BACKUP_NAME" -l "$BACKUP_LEVEL" -e - "$1" | write_backup; then
			msg -error "backup failed"
			exit 4
		fi
	fi
}

xfsdump_save() {
	# xfsdump has no post-save action
}

#endregion

#region Output management

_cleanup() {
	local file
	msg -debug "cleaning up temp files"
	for file in "$TEMP_FILES[@]"; do
		if [[ -f "$file" ]]; then
			msg -warn "$file exists, deleting"
			rm "$file"
		fi
	done
}

setup_output() {
	print -v BACKUP_FILE -P "$BACKUP_NAME-%D{%Y-%m-%d-%H:%M:%S}.L${BACKUP_LEVEL}.${FTYPE}.zst"
	if [[ -z $RECIPIENT_FILE && -f "$BACKUP_DIR/recipients.txt" ]]; then
		RECIPIENT_FILE="$BACKUP_DIR/recipients.txt"
	fi
	if [[ $RECIPIENT_FILE ]]; then
		BACKUP_FILE="${BACKUP_FILE}.age"
	fi
	msg "want to back up to $BACKUP_FILE"
	BACKUP_TMP="$BACKUP_DIR/$BACKUP_FILE.tmp"
	TEMP_FILES+="$BACKUP_TMP"
}

# write the backup to a temporary file, possibly encrypted
write_backup() {
	if [[ $RECIPIENT_FILE ]]; then
		msg "compressing and encrypting output"
		zstd -6 --no-progress | age -e -R "$RECIPIENT_FILE" -o "$BACKUP_TMP"
		return "$?"
	else
		msg "compressing output"
		zstd -6 --no-progress -o "$BACKUP_TMP"
		return "$?"
	fi
}

# move the backup temp into real
commit_backup() {
	msg -debug "committing backup"
	if ((!$opt_dry)); then
		msg -debug "moving temporary file $BACKUP_TMP"
		if ! mv "$BACKUP_TMP" "$BACKUP_DIR/$BACKUP_FILE"; then
			msg -error "failed to move $BACKUP_FILE.tmp to $BACKUP_FILE"
			exit 5
		else
			msg "%F{green}$BACKUP_FILE successfully created%f"
		fi
	fi
	${BACKUP_METHOD}_save
}

#endregion

#region Command-line argument parsing
zparseopts -D -E -F -a cli_opts - \
	c -cleanup n -dry-run v --verbose -rage -list \
	d: -backup-dir: \
	E: -encrypt-to: \
	S: -backup-schedule: \
	L: -level: \
	m: -method: \
	N: -name: \
	W: -work-dir: \
	x -one-file-system

if (($?)); then
	exit 2
fi
while ((${#cli_opts})); do
	flag="${cli_opts[1]}"
	shift cli_opts
	case "$flag" in
	-v | --verbose)
		opt_verbose=1
		;;
	-c | --cleanup)
		msg -debug "enabling cleanup"
		opt_cleanup=1
		;;
	-n | --dry-run)
		msg -debug "enabling dry-run"
		opt_dry=1
		;;
	--list)
		msg -debug "listing backups"
		action=list
		;;
	--rage)
		msg -debug "using rage"
		AGE=rage
		;;
	-d | --backup-dir)
		BACKUP_DIR="${cli_opts[1]}"
		shift cli_opts
		;;
	-S | --backup-schedule)
		BACKUP_SCHEDULE="${cli_opts[1]}"
		shift cli_opts
		;;
	-E | --encrypt-to)
		RECIPIENT_FILE="${cli_opts[1]}"
		shift cli_opts
		;;
	-L | --level)
		BACKUP_LEVEL="${cli_opts[1]}"
		shift cli_opts
		;;
	-m | --method)
		BACKUP_METHOD="${cli_opts[1]}"
		shift cli_opts
		;;
	-N | --name)
		BACKUP_NAME="${cli_opts[1]}"
		shift cli_opts
		;;
	-W | --work-dir)
		BACKUP_WORK="${cli_opts[1]}"
		shift cli_opts
		;;
	-x | --one-file-system)
		opt_onefs=1
		;;
	esac
done

case "$BACKUP_METHOD" in
gnutar)
	FTYPE=tar
	;;
xfsdump)
	FTYPE=dump
	;;
*)
	msg -error "unsupported method $BACKUP_METHOD"
	exit 2
	;;
esac

if [[ -z $BACKUP_DIR ]]; then
	msg -error "no backup directory specified"
	exit 2
fi

msg -debug "parsing backup time"
typeset -A NOW=($(_parse_time "${BACKUP_TIME}"))
#endregion

if [[ $action = list ]]; then
	list_backups
	exit
fi

scan_backups
configure_level

trap _cleanup EXIT TERM INT

if (($#)); then
	msg "want to back up $# paths"
	setup_output
	${BACKUP_METHOD}_init
	${BACKUP_METHOD}_prepare
	${BACKUP_METHOD}_backup "$@"
	commit_backup
else
	msg "no paths selected for backup"
fi

if (($opt_cleanup)); then
	clean_backups
fi
